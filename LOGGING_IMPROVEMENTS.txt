Proposition d'Amélioration du Logging pour fish_11_dll
======================================================

Analyse
-------
Le format de logging actuel dans `fish_11_dll` manque de structure et de
cohérence, ce qui rend le débogage et le suivi des opérations difficiles.
Il est nécessaire d'adopter un format plus riche et visuellement plus clair.


Vision d'ensemble : Le format de log proposé
--------------------------------------------

L'objectif est de passer d'un format simple et potentiellement ambigu à un
format structuré, aligné et riche en contexte.

Exemple de transformation :

Avant (Format simple):
-----------------------
INFO: Initializing configuration...
DEBUG: Loading keys from file.
ERROR: Encryption failed.
INFO: FFI call FiSH11_EncryptMsg completed.


Après (Format proposé):
------------------------
[14:32:05.123] [INFO ] [fish_11_dll::config]      [ThreadId(1)] Initializing configuration from C:\mIRC\fish11.ini...
[14:32:05.125] [DEBUG] [fish_11_dll::config::keys]  [ThreadId(1)] Loading 12 keys from file.
[14:32:05.450] [ERROR] [fish_11_dll::crypto]      [ThreadId(2)] [CTX:FiSH11_EncryptMsg] Encryption failed for target '#channel': Key not found.
[14:32:05.451] [INFO ] [fish_11_dll::ffi]         [ThreadId(2)] [CTX:FiSH11_EncryptMsg] Call completed with error code -5.


Actions proposées
-----------------

1. Adopter un Format de Log Structuré et Riche
----------------------------------------------
Chaque ligne de log devrait contenir des informations standardisées pour un
maximum de clarté :

- `[<Timestamp>]`: Un timestamp précis (ex: `HH:MM:SS.ms`).
- `[<Level>]`: Le niveau de log (`ERROR`, `WARN`, `INFO`, etc.), paddé avec
  des espaces pour un alignement parfait.
- `[<Module>]`: Le chemin complet du module Rust (`crate::module`), fourni par
  le framework de log. C'est la solution la plus efficace pour savoir d'où
  vient le log.
- `[<ThreadId>]`: L'identifiant du thread, crucial pour le débogage concurrent.
- `[CTX:<Context>]` (Optionnel): Un contexte fonctionnel (ex: nom de la
  fonction FFI) pour regrouper les logs par "section" logique.
- `<Message>`: Le message de log.


2. Implémentation via `env_logger`
----------------------------------
Le crate `env_logger` permet de définir ce format personnalisé dans
`fish_11_dll/src/logging.rs`.

Exemple de code d'initialisation :

    // Dans fish_11_dll/src/logging.rs
    use env_logger::Builder;
    use log::LevelFilter;
    use std::io::Write;
    use std::thread;

    pub fn init_logging(log_dir: &Path) -> Result<(), fern::InitError> {
        // ...
        let mut builder = Builder::new();

        builder
            .format(|buf, record| {
                let thread_id = thread::current().id();
                writeln!(
                    buf,
                    "[{}] [{:<5}] [{}] [{:?}] {}",
                    chrono::Local::now().format("%H:%M:%S%.3f"), // Timestamp
                    record.level(),                              // Level (paddé)
                    record.target(),                             // Module path
                    thread_id,                                   // Thread ID
                    record.args()                                // Message
                )
            })
            .filter(None, LevelFilter::Trace)
            .init();

        Ok(())
    }


3. Créer une Macro de Contexte pour les Sections Logiques
---------------------------------------------------------
Pour ajouter le contexte `[CTX:...]` de manière simple, une macro custom peut
être créée dans `logging_macros.rs`.

Exemple de macro :

    // Dans un nouveau fichier fish_11_dll/src/logging_macros.rs
    #[macro_export]
    macro_rules! log_ctx {
        ($ctx:expr, $level:ident, $($arg:tt)+) => {
            log::$level!(target: module_path!(), "[CTX:{}] {}", $ctx, format!($($arg)+));
        };
    }

Exemple d'utilisation :

    use crate::log_ctx;

    log_ctx!("FiSH11_EncryptMsg", INFO, "Received request for target '{}'", target_str);


4. Utiliser la Coloration pour une Différenciation Visuelle
-----------------------------------------------------------
Pour le débogage en console, `env_logger` peut colorer les logs par niveau,
ce qui aide à repérer les erreurs en un clin d'œil (ERROR en rouge, WARN en
jaune, etc.). Cette fonctionnalité est facile à activer et améliore grandement
la lisibilité.


Synthèse des Bénéfices
----------------------
1.  **Clarté immédiate**: Savoir d'où vient un log (module) et dans quel but
    (contexte).
2.  **Débogage facilité**: L'alignement, les couleurs et les IDs de thread
    permettent de suivre une requête de bout en bout.
3.  **Maintenabilité**: La macro `log_ctx!` encourage une journalisation
    contextuelle et cohérente.
4.  **Aucune perte d'information**: Le système est enrichi sans supprimer de
    détails.
